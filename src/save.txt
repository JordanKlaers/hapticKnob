#include <Arduino.h>
#include "./my_functions.h"
#include "Adafruit_GC9A01A.h"
#include "Wire.h"
#include <Adafruit_INA219.h>
#include <SimpleFOC.h>
#include "haptic.h"
#include <cmath>

#include <TFT_eSPI.h>
#define DELAY 1000

// Width and height of sprite
#define TFT_WIDTH  240
#define TFT_HEIGHT 240


TFT_eSPI tft = TFT_eSPI();
TFT_eSprite bg = TFT_eSprite(&tft);
TFT_eSprite dot = TFT_eSprite(&tft);
TFT_eSprite dial   = TFT_eSprite(&tft); // Sprite object for dial
TFT_eSprite needle = TFT_eSprite(&tft);
uint32_t startMillis;


/*-----------------------------------------------
	LCD Display
-----------------------------------------------*/
#define MISO   -1
#define SCLK   4
#define MOSI   5
#define RES    6
#define DC     7
#define CS     15
/*
SPIClass mySPI(FSPI);
Adafruit_GC9A01A tft(&mySPI, DC, CS, RES);
*/
float h = 0;
float outerRadius = 0;
float innerRadius = 0;
uint16_t screenBuffer[240 * 240];

/*-----------------------------------------------
	Motor Driver
-----------------------------------------------*/
#define UL 14 //red motor wire
#define UH 13 //red motor wire  - phase C
#define VL 12 //Blue motor wire
#define VH 21 //Blue motor wire -   pahse B
#define WL 47 //yellow motor wire
#define WH 48 //yellow motor wire - phase A
BLDCDriver6PWM driver = BLDCDriver6PWM(WH, WL, VH, VL, UH, UL);


//sparkfun motor
BLDCMotor motor = BLDCMotor(7);//, 7.8, 270);
//other motor
//BLDCMotor motor = BLDCMotor(6);



/*-----------------------------------------------
	Current Sensor
-----------------------------------------------*/
//the current sensor
/*
#define ma_sensor_addr_red_C (0x40) //Red motor wirie - Phase C
#define ma_sensor_addr_yellow_A (0x41) //Yellow motor wire - Phase A
#define ma_sensor_addr_blue_B (0x44) //Blue motor wire  - phase B
TwoWire currentSenseI2C(0);
Adafruit_INA219 current_sense_yellow_A(ma_sensor_addr_yellow_A);
Adafruit_INA219 current_sense_blue_B(ma_sensor_addr_blue_B);
Adafruit_INA219 current_sense_red_C(ma_sensor_addr_red_C);
#define cur_SDA_PIN 2
#define cur_SCL_PIN 1

float current_mA = 0;
// current sensor - this requires the modified simpleFoc library
InlineCurrentSense current_sense = InlineCurrentSense(&current_sense_red_C, &current_sense_blue_B, &current_sense_yellow_A);
*/



/*-----------------------------------------------
	Position Sensor
-----------------------------------------------*/
MagneticSensorI2C as5600 = MagneticSensorI2C(AS5600_I2C);
TwoWire positionSensorI2C(1);
#define pos_SDA_PIN 17
#define pos_SCL_PIN 16

/*-----------------------------------------------
	Haptic controller and things
-----------------------------------------------*/

PIDController P_haptic(1.2,0,0,100000,5);
float shaftVelocity = 60;
// attractor angle variable
float attract_angle = 0;
// distance between attraction points
float attractor_distance = (17.1428571429 * 3.14159265359f)/180.0; // 21 attractors should be divisible by 7 and work with the poll count hopeuflly
float findAttractor(float current_angle){
	return round(current_angle/attractor_distance)*attractor_distance;
}


/*-----------------------------------------------
	Tasks
-----------------------------------------------*/
TaskHandle_t motorTaskHandle;
TaskHandle_t lcdTaskHandle;
void motorTask(void *pvParameters);
void lcdTask(void *pvParameters);

std::array<float, 4> coordinates = {0.0f, 0.0f, 0.0f, 0.0f};
CircularBuffer buffer;
bool isFluttering = false;

Commander command = Commander(Serial);
void doMotor(char* cmd) { command.motor(&motor, cmd); }














//This one is for the lcd
float shaftAngle = 0;
//This one is for the motor
float currentShaftAngle = 0;

bool isWithinThreshold(float value1, float value2, float threshold) {
		// Calculate the absolute difference between the two values
		float absDiff = std::abs(value1 - value2);
		
		// Handle the special case where the values are close to the range boundary
		if (absDiff > 180.0) {
				absDiff = 360.0 - absDiff;
		}
		
		// Compare the absolute difference against the threshold
		return absDiff < threshold;
}
PhaseCurrent_s donk;

float normalizeRadians(float radians) {
		float twoPi = 2 * M_PI;
		radians = fmod(radians, twoPi);
		if (radians < 0) {
				radians += twoPi;
		}
		return radians;
}
int rot = 0;
int rotPrev = 0;
void drawX(int x, int y)
{
  tft.drawLine(x-5, y-5, x+5, y+5, TFT_WHITE);
  tft.drawLine(x-5, y+5, x+5, y-5, TFT_WHITE);
}







void createDialScale(int16_t start_angle, int16_t end_angle, int16_t increment)
{
  // Create the dial Sprite
  dial.setColorDepth(8);       // Size is odd (i.e. 91) so there is a centre pixel at 45,45
  dial.createSprite(91, 91);   // 8bpp requires 91 * 91 = 8281 bytes
  dial.setPivot(45, 45);       // set pivot in middle of dial Sprite

  // Draw dial outline
  dial.fillSprite(TFT_TRANSPARENT);           // Fill with transparent colour
  dial.fillCircle(45, 45, 43, TFT_DARKGREY);  // Draw dial outer

  // Hijack the use of the needle Sprite since that has not been used yet!
  needle.createSprite(3, 3);     // 3 pixels wide, 3 high
  needle.fillSprite(TFT_WHITE);  // Fill with white
  needle.setPivot(1, 43);        //  Set pivot point x to the Sprite centre and y to marker radius

  for (int16_t angle = start_angle; angle <= end_angle; angle += increment) {
    needle.pushRotated(&dial, angle); // Sprite is used to make scale markers
    yield(); // Avoid a watchdog time-out
  }

  needle.deleteSprite(); // Delete the hijacked Sprite
}


// =======================================================================================
// Add the empty dial face with label and value
// =======================================================================================

void drawEmptyDial(String label, int16_t val)
{
  // Draw black face
  dial.fillCircle(45, 45, 40, TFT_BLACK);
  dial.drawPixel(45, 45, TFT_WHITE);        // For demo only, mark pivot point with a while pixel

  dial.setTextDatum(TC_DATUM);              // Draw dial text
  dial.drawString(label, 45, 15, 2);
  dial.drawNumber(val, 45, 60, 2);
}

// =======================================================================================
// Update the dial and plot to screen with needle at defined angle
// =======================================================================================

void plotDial(int16_t x, int16_t y, int16_t angle, String label, uint16_t val)
{
  // Draw the blank dial in the Sprite, add label and number
  drawEmptyDial(label, val);

  // Push a rotated needle Sprite to the dial Sprite, with black as transparent colour
  needle.pushRotated(&dial, angle, TFT_BLACK); // dial is the destination Sprite

  // Push the resultant dial Sprite to the screen, with transparent colour
  dial.pushSprite(x, y, TFT_TRANSPARENT);
}

// =======================================================================================
// Create the needle Sprite and the image of the needle
// =======================================================================================

void createNeedle(void)
{
  needle.setColorDepth(8);
  needle.createSprite(11, 49); // create the needle Sprite 11 pixels wide by 49 high

  needle.fillSprite(TFT_BLACK);          // Fill with black

  // Define needle pivot point
  uint16_t piv_x = needle.width() / 2;   // x pivot of Sprite (middle)
  uint16_t piv_y = needle.height() - 10; // y pivot of Sprite (10 pixels from bottom)
  needle.setPivot(piv_x, piv_y);         // Set pivot point in this Sprite

  // Draw the red needle with a yellow tip
  // Keep needle tip 1 pixel inside dial circle to avoid leaving stray pixels
  needle.fillRect(piv_x - 1, 2, 3, piv_y + 8, TFT_RED);
  needle.fillRect(piv_x - 1, 2, 3, 5, TFT_YELLOW);

  // Draw needle centre boss
  needle.fillCircle(piv_x, piv_y, 5, TFT_MAROON);
  needle.drawPixel( piv_x, piv_y, TFT_WHITE);     // Mark needle pivot point with a white pixel
}






void setup() {
	Serial.begin(115200);

	// Add some sample values
	buffer.add(0.0f);
	buffer.add(0.0f);
	buffer.add(0.0f);
	/*
	currentSenseI2C.begin(cur_SDA_PIN, cur_SCL_PIN); //SDA - SCL
	 // Initialize the INA219 sensor
	if (!current_sense_yellow_A.begin(&currentSenseI2C)) {
		Serial.println("Failed to initialize current_sense_1!");
		while (1); // Halt the program if initialization fails
	}
	if (!current_sense_blue_B.begin(&currentSenseI2C)) {
		Serial.println("Failed to initialize current_sense_2!");
		while (1); // Halt the program if initialization fails
	}
	if (!current_sense_red_C.begin(&currentSenseI2C)) {
		Serial.println("Failed to initialize current_sense_3!");
		while (1); // Halt the program if initialization fails
	}
	current_sense.init();
	*/
	
	positionSensorI2C.begin(pos_SDA_PIN, pos_SCL_PIN);
	as5600.init(&positionSensorI2C);
	motor.linkSensor(&as5600);
	
	driver.voltage_power_supply = 5;
	driver.init();
	motor.linkDriver(&driver);
	motor.voltage_sensor_align = 5;
	// limiting motor movements
	//sparkfun motor
	motor.phase_resistance = 7.8; // [Ohm]
	//other motor
	//motor.phase_resistance = 12.5;
	motor.current_limit = 1.2;   // [Amps] - if phase resistance defined
	motor.voltage_limit = 5;   // [V] - if phase resistance not defined
	motor.velocity_limit = 20; // [rad/s] cca 50rpm
	motor.torque_controller = TorqueControlType::voltage;//TorqueControlType::voltage;
	motor.controller = MotionControlType::torque;
	
	motor.init();
	motor.initFOC();
	motor.target = 0;
	_delay(1000);

	
	tft.begin();
	tft.setRotation(1);
	tft.fillScreen(GC9A01A_BLACK);
	//tft.setPivot(TFT_WIDTH / 2, TFT_HEIGHT / 2);
	//bg.createSprite(241,241);
	//bg.setPivot(TFT_WIDTH / 2, TFT_HEIGHT / 2);
	//bg.pushSprite(0,0);


	dot.createSprite(240, 240);
	//dot.setPivot(12, 120);
	dot.fillSprite(TFT_TRANSPARENT);



	h = tft.getViewportHeight();
	outerRadius = h/2;
	innerRadius = (h/2) * 0.25;

	for (float i = 0; i < 361; i++) {
		
		addToCache(
			i,
			((innerRadius * cos(i * M_PI / 180.0f)) + outerRadius),
			((innerRadius * sin(i * M_PI / 180.0f)) + outerRadius),
			((outerRadius - 20) * cos(i * M_PI / 180.0f)) + outerRadius,
			((outerRadius - 20) * sin(i * M_PI / 180.0f)) + outerRadius
		);
	}

	//xTaskCreatePinnedToCore(motorTask, "MotorTask", 10000, NULL, 1, NULL, 0); // Task assigned to core 0
	//xTaskCreatePinnedToCore(lcdTask, "LCDTask", 10000, NULL, 1, NULL, 1); // Task assigned to core 1
}

void loop() {
	
	// int prev = 0;
	// for (int rot = 0; rot < 361; rot++) {
	// 	//bg.fillSprite(TFT_BLACK);
	// 	dot.fillSmoothCircle(12, 14, 9, GC9A01A_BLACK, GC9A01A_BLACK);
	// 	dot.pushRotated(prev, TFT_TRANSPARENT);
	// 	dot.fillSmoothCircle(12, 14, 9, GC9A01A_WHITE, GC9A01A_BLACK);
	// 	dot.pushRotated(rot, TFT_TRANSPARENT);
	// 	//bg.pushSprite(0,0,TFT_TRANSPARENT);
	// 	prev = rot;
	// }

	shaftAngle = normalizeRadians(as5600.getSensorAngle());
	float shaftDegree = round(shaftAngle * (360.0f / (2 * M_PI)));
	//reading a new degree
	if (shaftDegree != buffer.getLast()) {
		//if its not fluttering, we can add the new value
		if (!isFluttering) {
			//+/- 1 and not fluttering
			isFluttering = buffer.add(shaftDegree);
			//erase the old
			coordinates = getFromCache(buffer.getSecondLast());
			dot.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_BLACK);
			//draw the new
			coordinates = getFromCache(buffer.getLast());
			dot.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_WHITE);
		}
		//if its fluttering, then we only add new value if tis +/- 2
		else if (!isWithinThreshold(shaftDegree, buffer.getLast(), 2)) {
			isFluttering = buffer.add(shaftDegree);
			//erase the old
			coordinates = getFromCache(buffer.getSecondLast());
			dot.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_BLACK);
			//draw the new
			coordinates = getFromCache(buffer.getLast());
			dot.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_WHITE);
		}
		dot.pushSprite(0,0);
	}
	/*

	shaftAngle = normalizeRadians(as5600.getSensorAngle());
	float shaftDegree = round(shaftAngle * (360.0f / (2 * M_PI)));
	//reading a new degree
	if (shaftDegree != buffer.getLast()) {
		//if its not fluttering, we can add the new value
		if (!isFluttering) {
			//+/- 1 and not fluttering
			isFluttering = buffer.add(shaftDegree);
			dot.fillSmoothCircle(12, 14, 9, GC9A01A_BLACK, GC9A01A_BLACK);
			dot.pushRotated(&bg, buffer.getSecondLast(), TFT_TRANSPARENT);
			dot.fillSmoothCircle(12, 14, 9, GC9A01A_WHITE, GC9A01A_BLACK);
			dot.pushRotated(&bg, buffer.getLast(), TFT_TRANSPARENT);
			bg.pushSprite(0,0,TFT_TRANSPARENT);
		}
		//if its fluttering, then we only add new value if tis +/- 2
		else if (!isWithinThreshold(shaftDegree, buffer.getLast(), 2)) {
			isFluttering = buffer.add(shaftDegree);
			dot.fillSmoothCircle(12, 14, 9, GC9A01A_BLACK, GC9A01A_BLACK);
			dot.pushRotated(&bg, buffer.getSecondLast(), TFT_TRANSPARENT);
			dot.fillSmoothCircle(12, 14, 9, GC9A01A_WHITE, GC9A01A_BLACK);
			dot.pushRotated(&bg, buffer.getLast(), TFT_TRANSPARENT);
			bg.pushSprite(0,0,TFT_TRANSPARENT);
		}
	}
	*/
/*
	tft.fillScreen(TFT_DARKGREY);
  spr.setColorDepth(4);
  spr.createSprite(240, 240); // The Sprite MUST be created before setting the palette!
for (uint8_t i = 0; i < 16; i++) {
    spr.setPaletteColor(i, tft.color565(i*16+i, i*16+i, i*16+i));
  }

  uint16_t color15 = spr.getPaletteColor(15); // The 16-bit colour in a palette can be read back
  	int prev = 0;
	for (int rot = 0; rot < 361; rot++) {
		coordinates = getFromCache(prev);
		spr.fillSprite(15);
		spr.fillCircle(coordinates[2], coordinates[3], 10, 15);
		coordinates = getFromCache(rot);
		spr.fillCircle(coordinates[2], coordinates[3], 10, random(0x10));
		spr.pushSprite(0, 0, 15);
		prev = rot;
	}
  
  spr.deleteSprite();

  delay(2000);
  */
  /*


	shaftAngle = normalizeRadians(as5600.getSensorAngle());
	float shaftDegree = round(shaftAngle * (360.0f / (2 * M_PI)));
	//reading a new degree
	if (shaftDegree != buffer.getLast()) {
		//if its not fluttering, we can add the new value
		if (!isFluttering) {
			//+/- 1 and not fluttering
			isFluttering = buffer.add(shaftDegree);
			//erase the old
			coordinates = getFromCache(buffer.getSecondLast());
			tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_BLACK);
			//draw the new
			coordinates = getFromCache(buffer.getLast());
			tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_WHITE);
		}
		//if its fluttering, then we only add new value if tis +/- 2
		else if (!isWithinThreshold(shaftDegree, buffer.getLast(), 2)) {
			isFluttering = buffer.add(shaftDegree);
			//erase the old
			coordinates = getFromCache(buffer.getSecondLast());
			tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_BLACK);
			//draw the new
			coordinates = getFromCache(buffer.getLast());
			tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_WHITE);
		}
	}
	*/
}


void motorTask(void *pvParameters) {
	while (1) {
		motor.loopFOC();
		currentShaftAngle = motor.shaft_angle;
		motor.move(P_haptic(attract_angle - currentShaftAngle));
		attract_angle = findAttractor(currentShaftAngle);
	}
}
void lcdTask(void *pvParameters) {
	while (1) {
		shaftAngle = normalizeRadians(motor.shaft_angle);
		float shaftDegree = round(shaftAngle * (360.0f / (2 * M_PI)));
		//reading a new degree
		if (shaftDegree != buffer.getLast()) {
			//if its not fluttering, we can add the new value
			if (!isFluttering) {
				//+/- 1 and not fluttering
				isFluttering = buffer.add(shaftDegree);

				//erase the old
				coordinates = getFromCache(buffer.getSecondLast());
				tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_BLACK);
				//draw the new
				coordinates = getFromCache(buffer.getLast());
				tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_WHITE);
			}
			//if its fluttering, then we only add new value if tis +/- 2
			else if (!isWithinThreshold(shaftDegree, buffer.getLast(), 2)) {
				isFluttering = buffer.add(shaftDegree);

				//erase the old
				coordinates = getFromCache(buffer.getSecondLast());
				tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_BLACK);
				//draw the new
				coordinates = getFromCache(buffer.getLast());
				tft.fillCircle(coordinates[2] - 5, coordinates[3] - 5, 10, GC9A01A_WHITE);
			}
		}
	}
}

