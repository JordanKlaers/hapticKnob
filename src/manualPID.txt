// This sketch is for the RP2040 and ILI9341 TFT display.
// Other processors may work if they have sufficient RAM for
// a full screen displayAngleHistory (240 x 320 x 2 = 153,600 bytes).

// In this example 2 sprites are used to create DMA toggle
// buffers. Each sprite is half the screen size, this allows
// graphics to be rendered in one sprite at the same time
// as the other sprite is being sent to the screen.

// RP2040 typically runs at 45-48 fps

// Created by Bodmer 20/04/2021 as an example for:
// https://github.com/Bodmer/TFT_eSPI
#include <Arduino.h>
#include "./my_functions.h"
#include "Adafruit_GC9A01A.h"
#include "Wire.h"
#include <Adafruit_INA219.h>
#include <SimpleFOC.h>
#include "haptic.h"
#include <cmath>
#include <TFT_eSPI.h>
#include <random>
#include <iostream>
#include <string>

/*-----------------------------------------------
	Display
-----------------------------------------------*/
#define DWIDTH  240
#define DHEIGHT 240
TFT_eSPI    tft = TFT_eSPI();
TFT_eSprite spr[4] = {TFT_eSprite(&tft), TFT_eSprite(&tft), TFT_eSprite(&tft), TFT_eSprite(&tft)};
uint16_t* sprPtr[1];

CircularBuffer displayAngleHistory;											//This displayAngleHistory stores the positions of the dot - by degree
CircularBuffer motorAngleHistory;
bool displayIsFluttering = false;										//variable to help stablize when the know is not spinning
bool motorIsFluttering = false;	
float motorShaftAngle = 0;


/*-----------------------------------------------
	Position Sensor
-----------------------------------------------*/
MagneticSensorI2C as5600 = MagneticSensorI2C(AS5600_I2C);
TwoWire positionSensorI2C(1);
#define pos_SDA_PIN 17
#define pos_SCL_PIN 16


/*-----------------------------------------------
	Motor Driver
-----------------------------------------------*/
#define UL 14 //red motor wire
#define UH 13 //red motor wire  - phase C
#define VL 12 //Blue motor wire
#define VH 21 //Blue motor wire -   pahse B
#define WL 47 //yellow motor wire
#define WH 48 //yellow motor wire - phase A
BLDCDriver6PWM driver = BLDCDriver6PWM(WH, WL, VH, VL, UH, UL);
//sparkfun motor
BLDCMotor motor = BLDCMotor(7);


/*-----------------------------------------------
	Haptic controller and things
-----------------------------------------------*/
PIDController P_haptic(0.8,0,0,100000,5);
float attract_angle = 0;
float attractor_distance = (17.1428571429 * 3.14159265359f)/180.0; // 21 attractors should be divisible by 7 and work with the poll count hopeuflly
float findAttractor(float current_angle){
	return round(current_angle/attractor_distance)*attractor_distance;
}

/*-----------------------------------------------
	Tasks
-----------------------------------------------*/
TaskHandle_t motorTaskHandle;
TaskHandle_t lcdTaskHandle;
void motorTask(void *pvParameters);
void lcdTask(void *pvParameters);
QueueHandle_t floatQueue;

volatile float sharedAngle;
float leftAttractor = 0.7853981;
float rightAttractor = 5.49778;


/*-----------------------------------------------
	Buttons
-----------------------------------------------*/
int button1 = 18;
int button2 = 8;
int button3 = 3;
int button4 = 11;

/*-----------------------------------------------
	WIFI stuff
-----------------------------------------------*/
uint8_t broadcastAddress[] = {0xA4, 0xCF, 0x12, 0xD9, 0x0A, 0x66};
SemaphoreHandle_t xBinarySemaphore;
void setup() {
	Serial.begin(115200);
	pinMode(button1, INPUT);
	pinMode(button2, INPUT);
	pinMode(button3, INPUT);
	pinMode(button4, INPUT);

	positionSensorI2C.begin(pos_SDA_PIN, pos_SCL_PIN);
	as5600.init(&positionSensorI2C);
	// Add some sample values
	displayAngleHistory.add(0.0f);
	displayAngleHistory.add(0.0f);
	displayAngleHistory.add(0.0f);
	motorAngleHistory.add(0.0f);
	motorAngleHistory.add(0.0f);
	motorAngleHistory.add(0.0f);

	motor.linkSensor(&as5600);
	driver.voltage_power_supply = 5;
	driver.init();
	motor.linkDriver(&driver);
	motor.voltage_sensor_align = 5;
	motor.phase_resistance = 7.8; // [Ohm]
	motor.current_limit = 1.2;   // [Amps] - if phase resistance defined
	motor.voltage_limit = 5;   // [V] - if phase resistance not defined
	motor.velocity_limit = 20; // [rad/s] cca 50rpm
	//motor.torque_controller = TorqueControlType::voltage;//TorqueControlType::voltage;
	motor.controller = MotionControlType::torque;
	
	motor.init();
	motor.initFOC();
	_delay(1000);


	// tft.init();
	// tft.initDMA();
	// tft.fillScreen(TFT_BLACK);

	// // Create the 2 sprites, each is half the size of the screen
	// sprPtr[0] = (uint16_t*)spr[0].createSprite(DWIDTH, DHEIGHT);
	// spr[0].fillSprite(TFT_TRANSPARENT);
	
	// //for the 2 ticks
	// spr[1].createSprite(6, DHEIGHT / 2);
	// spr[1].setPivot(3.5, DHEIGHT / 2);
	// spr[1].fillSprite(TFT_TRANSPARENT);
	// //for the dot(white)
	// spr[2].createSprite(24, DHEIGHT / 2);
	// spr[2].setPivot(12, DHEIGHT / 2);
	// spr[2].fillSprite(TFT_TRANSPARENT);
	// spr[2].fillCircle(12, 14, 10, GC9A01A_WHITE);
	// //for text in the middle
	// spr[3].createSprite(DWIDTH, DHEIGHT);
	// spr[3].setPivot(DWIDTH / 2, DHEIGHT / 2);
	// spr[3].fillSprite(TFT_TRANSPARENT);
	// spr[3].setTextDatum(MC_DATUM);
	// spr[3].setTextColor(GC9A01A_WHITE);
	// spr[3].setTextSize(5);
	// spr[3].setTextFont(0);

	// tft.startWrite(); // TFT chip select held low permanently

	xTaskCreatePinnedToCore(motorTask, "MotorTask", 40000, NULL, 1, &motorTaskHandle, 1);
	// xTaskCreatePinnedToCore(lcdTask, "LCDTask", 40000, NULL, 2, &lcdTaskHandle, 0);
	// xBinarySemaphore = xSemaphoreCreateBinary();
    // if (xBinarySemaphore != NULL) {
    //     // Initial give to allow tasks to take it
    //     xSemaphoreGive(xBinarySemaphore);

    //     // Create the tasks
    //     xTaskCreatePinnedToCore(motorTask, "MotorTask", 40000, NULL, 1, &motorTaskHandle, 1);
	// 	// xTaskCreatePinnedToCore(lcdTask, "LCDTask", 40000, NULL, 2, &lcdTaskHandle, 0);

    //     // Start the scheduler
    //     vTaskStartScheduler();
    // } else {
    //     // Handle error if semaphore creation failed
    //     Serial.println("Failed to create semaphore.");
    // }
	//disableCore0WDT();
}

void loop() {
    // Empty loop function to comply with Arduino framework requirements
}
// Serial loop function to handle incoming data
void serialLoop() {
    static String received_chars;
    static float p = 0.0; // Variable to store 'p' values
    static float i = 0.0; // Variable to store 'i' values
    static float d = 0.0; // Variable to store 'd' values

    while (Serial.available()) {
        char inChar = (char) Serial.read();
        received_chars += inChar;

        if (inChar == '\n') {
            // Parse the received_chars string
            char identifier = received_chars.charAt(0); // Get the identifier character ('p' or 'i' or 'd')
            float value = received_chars.substring(2).toFloat(); // Extract and convert the number part

            // Assign the value to the corresponding variable
            if (identifier == 'p') {
                p = value;
                P_haptic.P = p;
            } else if (identifier == 'i') {
                i = value;
                P_haptic.I = i;
            } else if (identifier == 'd') {
                d = value;
                P_haptic.D = d;
            } else {
                Serial.println("Invalid identifier");
            }

            Serial.print("p: ");
            Serial.println(p);
            Serial.print("i: ");
            Serial.println(i);
            Serial.print("d: ");
            Serial.println(d);

            // Clear the received_chars for the next input
            received_chars = "";
        }
    }
}

// Motor control task
void motorTask(void *pvParameters) {
    TickType_t xLastWakeTime;
    const TickType_t xFrequency = pdMS_TO_TICKS(1000); // Calculate every second
    unsigned long loopCount = 0;
    float motorShaftAngle;
    float attract_angle = 0;
	unsigned long previousMillis = 0;  // Stores the last time the action was performed
    const long interval = 2000;
    // Initialize the last wake time to the current tick count
    xLastWakeTime = xTaskGetTickCount();

    for( ;; ) {
        // if (xSemaphoreTake(xBinarySemaphore, 0) == pdTRUE) {
            TickType_t start = xTaskGetTickCount();

            motor.loopFOC();
            motorShaftAngle = motor.shaft_angle;
            if (fabsf(motor.shaft_velocity) > 60) {
                motor.move(0);
            } else {
                motor.move(P_haptic(attract_angle - motorShaftAngle));
            }
            attract_angle = findAttractor(motorShaftAngle);

            TickType_t end = xTaskGetTickCount();
            loopCount++;
            if (end - xLastWakeTime >= xFrequency) {
                float frequency = (float)loopCount / ((float)(end - xLastWakeTime) / (float)configTICK_RATE_HZ);
                printf("Loop frequency: %f Hz\n", frequency);
                loopCount = 0;
                xLastWakeTime = end;
            }
			unsigned long currentMillis = millis();
        	if (currentMillis - previousMillis >= interval) {
				if  (Serial.available()) {
					serialLoop();
				}
				previousMillis = currentMillis;
			}
            // xSemaphoreGive(xBinarySemaphore);
        // }
    }
}

// LCD task
void lcdTask(void *pvParameters) {
    unsigned long previousMillis = 0;  // Stores the last time the action was performed
    const long interval = 500;

    for( ;; ) {
        unsigned long currentMillis = millis();
        if (currentMillis - previousMillis >= interval) {
            if (Serial.available()) {
                // Take the semaphore and process serial data
                if (xSemaphoreTake(xBinarySemaphore, portMAX_DELAY) == pdTRUE) {
                    serialLoop();
                    xSemaphoreGive(xBinarySemaphore);
                }
            }
            previousMillis = currentMillis;
        }
    }
}